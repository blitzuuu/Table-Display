<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Config Page</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@100..900&display=swap" rel="stylesheet">
  <style>
    :root{
      --container-width: 300px;
      --container-padding: 20px;
      --gap: 15px;
      --control-height: 36px; /* unified height for input, align buttons, and update/reset */
      --field-bg: #d3d3d3;
      --selected-bg: #0d6efd;
      --selected-color: #fff;
      --text-color: #000;
      --font-size: 14px;
      --align-font-size: 13px;
      --button-gap: 8px;
    }

    html,body{
      height:100%;
      margin:0;
    }

    body {
      font-family: 'Inter', sans-serif;
      margin: 0;
      padding: 0;
      background-color: #18181b;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
    }

    /* Make container use border-box so children with width:100% line up perfectly */
    .config-container {
      width: var(--container-width);
      padding: var(--container-padding);
      box-sizing: border-box;
    }

    .config-container label {
      display: block;
      font-size: var(--font-size);
      margin-bottom: 5px;
      color: white;
    }

    /* ---- IMPORTANT: use border-box and width:100% so everything lines up exactly ---- */
    .config-container input {
      width: 100%;
      box-sizing: border-box;
      padding: 8px 12px;
      margin-bottom: var(--gap);
      border: none;
      border-radius: 5px;
      background-color: var(--field-bg);
      color: var(--text-color);
      font-size: var(--font-size);
      height: var(--control-height); /* matches buttons */
      line-height: 1.1;
    }
    .config-container input:focus { outline: none; }

    /* Align group uses width:100% and flex children that expand equally */
    .align-group {
      width: 100%;
      display: flex;
      gap: var(--button-gap);
      margin-bottom: var(--gap);
      box-sizing: border-box;
    }

    .align-group .align-btn {
      flex: 1 1 0;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 6px 8px;
      height: var(--control-height);
      box-sizing: border-box;
      background-color: var(--field-bg);
      color: var(--text-color);
      border: none;
      border-radius: 5px;
      font-size: var(--align-font-size);
      cursor: pointer;
      text-align: center;
      /* allow wrapping if needed but center vertically */
      white-space: normal;
      line-height: 1.05;
      word-break: break-word;
    }

    .align-group .align-btn:focus {
      outline: none;
      box-shadow: 0 0 0 3px rgba(13,110,253,0.12);
    }

    .align-group .align-btn.selected{
      background-color: var(--selected-bg);
      color: var(--selected-color);
    }

    /* Button group now uses flex with gap and flex:1 so its total width equals the input & align-group */
    .button-group {
      display: flex;
      gap: var(--button-gap);
      width: 100%;
      box-sizing: border-box;
    }

    .button-group button {
      flex: 1 1 0;
      padding: 8px 12px;
      font-size: var(--font-size);
      border: none;
      cursor: pointer;
      border-radius: 5px;
      color: white;
      height: var(--control-height);
      box-sizing: border-box;
      opacity: 0.95;
    }
    .button-group button.update { background-color: #5cb85c; }
    .button-group button.reset { background-color: #d9534f; }
    .button-group button:hover { opacity: 1; }

    /* small responsive tweak */
    @media (max-width: 360px) {
      :root { --container-width: 92vw; }
      .align-group .align-btn { font-size: 12px; }
    }
  </style>
</head>
<body>
  <div class="config-container">
    <label for="tableid-input">Table ID</label>
    <input type="text" id="tableid-input" placeholder="Enter Table ID" />

    <label for="align-select">Text Alignment</label>
    <div class="align-group" role="radiogroup" aria-label="Text Alignment">
      <button type="button" class="align-btn" data-align="left" id="align-left" aria-pressed="true">Left</button>
      <button type="button" class="align-btn" data-align="center" id="align-center" aria-pressed="false">Centered (War)</button>
      <button type="button" class="align-btn" data-align="right" id="align-right" aria-pressed="false">Right</button>
    </div>

    <input type="hidden" id="align-value" value="left" />

    <div class="button-group">
      <button class="update" id="update-btn">Update</button>
      <button class="reset" id="reset-btn">Reset</button>
    </div>
  </div>

  <script>
    document.addEventListener("DOMContentLoaded", async () => {
      const urlParams = new URLSearchParams(window.location.search);
      const name = urlParams.get("name");
      const currentTableId = urlParams.get("tableid") || "";
      const currentAlign = (urlParams.get("align") || "left").toLowerCase();

      const tableIdInput = document.getElementById("tableid-input");
      const alignValueInput = document.getElementById("align-value");
      const alignButtons = Array.from(document.querySelectorAll(".align-btn"));
      const updateBtn = document.getElementById("update-btn");
      const resetBtn = document.getElementById("reset-btn");

      tableIdInput.value = currentTableId;

      function setSelectedButton(value) {
        alignButtons.forEach(btn => {
          const btnAlign = btn.getAttribute("data-align");
          const selected = btnAlign === value;
          btn.classList.toggle("selected", selected);
          btn.setAttribute("aria-pressed", selected ? "true" : "false");
        });
        alignValueInput.value = value;
      }

      if (["left", "center", "right"].includes(currentAlign)) {
        setSelectedButton(currentAlign);
      } else {
        setSelectedButton("left");
      }

      alignButtons.forEach(btn => {
        btn.addEventListener("click", () => {
          const value = btn.getAttribute("data-align");
          setSelectedButton(value);
        });
        btn.addEventListener("keydown", (e) => {
          if (e.key === " " || e.key === "Enter") {
            e.preventDefault();
            const value = btn.getAttribute("data-align");
            setSelectedButton(value);
            btn.focus();
          }
        });
      });

      // Robust showCheckmark: store original HTML, clear previous timeout if any,
      // and restore original text after 3s. This fixes the issue where the Update
      // button sometimes remained a checkmark permanently.
      function showCheckmark(button) {
        // clear any previously scheduled restore for this button
        if (button.dataset._checkTimeoutId) {
          clearTimeout(Number(button.dataset._checkTimeoutId));
          delete button.dataset._checkTimeoutId;
        }

        // store original HTML if not already stored
        if (!button.dataset._originalHtml) {
          button.dataset._originalHtml = button.innerHTML;
        }

        // set checkmark
        button.innerHTML = "<b>âœ”</b>";

        // schedule restore
        const id = setTimeout(() => {
          // restore original HTML (fallback to literal "Update"/"Reset" if missing)
          button.innerHTML = button.dataset._originalHtml || (button.classList.contains('update') ? 'Update' : 'Reset');
          // clean up dataset keys so future clicks behave the same
          delete button.dataset._checkTimeoutId;
          delete button.dataset._originalHtml;
        }, 3000);

        // save timeout id so we can clear it if the button is clicked again quickly
        button.dataset._checkTimeoutId = String(id);
      }

      function resetInput() { tableIdInput.value = ""; }

      // Fetch/validate player_data.json (unchanged behaviour)
      try {
        const response = await fetch("player_data.json");
        const playerData = await response.json();
        const validNames = playerData.map(player => player.name);
        if (!name || !validNames.includes(name)) {
          document.body.innerHTML = `<h1>Error</h1><p>The config page cannot be used without a valid 'name' parameter in the URL.</p>`;
          return;
        }
      } catch (error) {
        document.body.innerHTML = `<h1>Error</h1><p>Error loading player data. Please try again later.</p>`;
        return;
      }

      updateBtn.addEventListener("click", () => {
        const newTableId = tableIdInput.value.trim();
        const selectedAlign = alignValueInput.value || "left";
        const channel = new BroadcastChannel("table_config_channel");
        channel.postMessage({ name, tableid: newTableId, align: selectedAlign });

        // show checkmark and restore after timeout (robust)
        showCheckmark(updateBtn);
      });

      resetBtn.addEventListener("click", () => {
        resetInput();
        const channel = new BroadcastChannel("table_config_channel");
        channel.postMessage({ name, tableid: "", align: alignValueInput.value || "left" });

        // show checkmark and restore after timeout (robust)
        showCheckmark(resetBtn);
      });
    });
  </script>
</body>
</html>
