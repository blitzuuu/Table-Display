<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Table Display</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: transparent;
            font-family: 'Roboto Mono', monospace;
        }
        /* Make the element exactly 1920px wide so OBS doesn't need adjustments */
        #table-stats {
            position: absolute;
            top: 10px;
            left: 0; /* anchor to left to match a 1920px wide element */
            width: 1920px;
            font-size: 30px; /* Base font size */
            font-weight: 500;
            box-sizing: border-box;
            padding: 0 10px;
            white-space: nowrap;
        }

        /* Flex container used for centered war layout */
        .war-center {
            display: flex;
            justify-content: center;
            align-items: flex-end; /* align bottoms so race-count can be aligned to bottom */
            gap: 12px;
        }

        /* Box styles */
        .war-box {
            display: flex;
            align-items: center;
            justify-content: center;
            background: transparent;
            box-sizing: border-box;
        }

        .war-box .text {
            display: block;
            font-family: 'Roboto Mono', monospace;
            font-weight: 600;
            line-height: 1;
            white-space: nowrap;
        }

        .war-box.tag .text { /* Box A styling */
            font-weight: 700;
        }

        .war-box.score .text { /* Box B styling */
            font-weight: 700;
        }

        .war-box.race .text { /* Box C styling: slightly smaller */
            font-size: 0.75em;
            font-weight: 700;
            line-height: 1;
        }

        /* Text alignment helpers inside each box */
        .left-align { text-align: left; width: 100%; padding-left: 6px; box-sizing: border-box; }
        .right-align { text-align: right; width: 100%; padding-right: 6px; box-sizing: border-box; }
        .center-align { text-align: center; width: 100%; box-sizing: border-box; }

        /* Styling for dark/white modes (keep existing behavior) */
        .dark-mode .text-highlight {
            color: black;
        }
        .dark-mode .text-normal {
            color: #444444;
        }
        .white-mode .text-highlight {
            color: white;
        }
        .white-mode .text-normal {
            color: #bebebe;
        }
    </style>
</head>
<body>
    <div id="table-stats"></div>

    <script>
        // Utility: format tags consistently
        function formatTag(tag) {
            if (tag.startsWith('[') && tag.endsWith(']')) return tag;
            return `[${tag}]`;
        }

        async function fetchAndRenderData() {
            try {
                const urlParams = new URLSearchParams(window.location.search);
                const tableId = urlParams.get("tableid");
                const playerName = urlParams.get("name");
                const align = (urlParams.get("align") || "left").toLowerCase();

                // styling mode
                if (urlParams.has("white")) {
                    document.body.classList.add("white-mode");
                    document.body.classList.remove("dark-mode");
                } else {
                    document.body.classList.add("dark-mode");
                    document.body.classList.remove("white-mode");
                }

                if (!tableId) {
                    document.getElementById("table-stats").innerHTML = "";
                    return;
                }

                const tableResponse = await fetch(`https://mkw-table-bot-api.jprq.live/api/html/full_scores/${tableId}`);
                if (!tableResponse.ok) {
                    document.getElementById("table-stats").innerHTML = "";
                    return;
                }

                const tableHTML = await tableResponse.text();
                const parsed = parseTableData(tableHTML, playerName);

                // If center requested but not exactly two teams, fallback to left
                const effectiveAlign = (align === 'center' && parsed.teams && parsed.teams.length === 2) ? 'center' : (align === 'center' ? 'left' : align);

                render(parsed, effectiveAlign);
            } catch (error) {
                console.error("Error fetching or rendering data:", error);
                document.getElementById("table-stats").innerHTML = "";
            }
        }

        // Parse table HTML into a structured object
        function parseTableData(rawHTML, playerName) {
            const temp = document.createElement("div");
            temp.innerHTML = rawHTML;

            const raceInfo = temp.querySelector(".races_played")?.textContent || "";
            const raceMatch = raceInfo.match(/(\d+)\s*races?/i);
            const raceNumber = raceMatch ? raceMatch[1] : "1";

            const format = temp.querySelector(".format")?.textContent.trim() || "Unknown";

            if (format === "FFA") {
                const players = Array.from(temp.querySelectorAll(".player_wrapper")).map(player => {
                    const pName = player.querySelector(".player_name")?.textContent.trim() || "Unknown";
                    const pTotal = parseInt(player.querySelector(".player_total")?.textContent.trim() || "0", 10);
                    return { name: pName, total: pTotal };
                });
                players.sort((a,b) => b.total - a.total);
                return { type: 'ffa', raceNumber, format, players };
            } else {
                const teams = Array.from(temp.querySelectorAll(".team_wrapper")).map(team => {
                    const teamName = team.querySelector(".team_name")?.textContent.trim() || "Unknown";
                    const teamScore = team.querySelector(".team_score")?.textContent.trim() || "0";
                    const players = Array.from(team.querySelectorAll(".player_name")).map(p => p.textContent.trim());
                    return { name: teamName, score: teamScore, players };
                });

                return { type: 'teams', raceNumber, format, teams };
            }
        }

        // Render structured data according to effectiveAlign ('left'|'right'|'center')
        function render(parsed, effectiveAlign) {
            const container = document.getElementById("table-stats");
            container.innerHTML = "";

            if (parsed.type === 'ffa') {
                // same rendering as before for FFA
                const playerScores = parsed.players.map(p => `<span class="text-normal">${p.total}</span>`);
                container.innerHTML = `<span class="text-normal">R${parsed.raceNumber} ${parsed.format}</span> <span class="text-normal">|</span> ${playerScores.join('<span class="text-normal">, </span>')}`;
                container.style.textAlign = effectiveAlign === 'right' ? 'right' : 'left';
                if (effectiveAlign === 'center') container.style.textAlign = 'center';
                return;
            }

            // Teams rendering
            if (effectiveAlign === 'center' && parsed.teams.length === 2) {
                renderWarCenter(container, parsed);
                return;
            }

            // Default teams rendering (left/right/center simple join)
            const teamScoresHtml = parsed.teams.map(team => `<span class="text-normal">${formatTag(team.name)} ${team.score}</span>`);
            container.innerHTML = `<span class="text-normal">R${parsed.raceNumber} ${parsed.format}</span> <span class="text-normal">|</span> ${teamScoresHtml.join('<span class="text-normal"> | </span>')}`;
            container.style.textAlign = effectiveAlign === 'right' ? 'right' : (effectiveAlign === 'center' ? 'center' : 'left');
        }

        // Build the special "Centered (War)" layout in DOM (not plain HTML string)
        function renderWarCenter(container, parsed) {
            // container: #table-stats
            // parsed.teams: [{name, score}, {name, score}]
            // We need to measure monospace character width at the container font-size.
            // Create an offscreen span to measure a character in same font.
            const meas = document.createElement('span');
            meas.style.position = 'absolute';
            meas.style.left = '-9999px';
            meas.style.top = '-9999px';
            meas.style.visibility = 'hidden';
            meas.style.fontFamily = getComputedStyle(container).fontFamily || 'Roboto Mono, monospace';
            meas.style.fontSize = getComputedStyle(container).fontSize || '30px';
            meas.style.fontWeight = getComputedStyle(container).fontWeight || '500';
            meas.textContent = '0'.repeat(40); // long string
            document.body.appendChild(meas);
            const totalWidth = meas.getBoundingClientRect().width;
            const charWidth = totalWidth / 40;
            document.body.removeChild(meas);

            const padding = Math.round(charWidth * 0.6); // a little padding inside boxes

            const tag1 = formatTag(parsed.teams[0].name);
            const tag2 = formatTag(parsed.teams[1].name);
            const score1 = parsed.teams[0].score;
            const score2 = parsed.teams[1].score;
            const raceLabel = `R${parsed.raceNumber} ${parsed.format}`;

            // Compute widths in px
            const lenTag1 = tag1.length;
            const lenTag2 = tag2.length;
            const boxAChars = Math.max(lenTag1, lenTag2); // Box A: width based on larger tag
            const boxAWidth = Math.ceil(boxAChars * charWidth) + padding * 2;

            const boxBChars = 3; // 3 character widths
            const boxBWidth = Math.ceil(boxBChars * charWidth) + padding * 2;

            const boxCChars = Math.max(1, Math.floor(boxBChars * 0.8)); // slightly smaller than B
            const boxCWidth = Math.ceil(boxCChars * charWidth) + padding * 2;

            // Build DOM nodes
            const wrapper = document.createElement('div');
            wrapper.className = 'war-center';

            // Left Tag (Box A) - left aligned text inside
            const leftTagBox = document.createElement('div');
            leftTagBox.className = 'war-box tag';
            leftTagBox.style.width = boxAWidth + 'px';
            leftTagBox.style.textAlign = 'left';
            const leftTagSpan = document.createElement('span');
            leftTagSpan.className = 'text left-align';
            leftTagSpan.textContent = tag1;
            leftTagBox.appendChild(leftTagSpan);

            // Left Score (Box B) - left aligned
            const leftScoreBox = document.createElement('div');
            leftScoreBox.className = 'war-box score';
            leftScoreBox.style.width = boxBWidth + 'px';
            leftScoreBox.style.textAlign = 'left';
            const leftScoreSpan = document.createElement('span');
            leftScoreSpan.className = 'text left-align';
            leftScoreSpan.textContent = score1;
            leftScoreBox.appendChild(leftScoreSpan);

            // Race Count (Box C) - smaller font, center aligned, bottom aligned with other text
            const raceBox = document.createElement('div');
            raceBox.className = 'war-box race';
            raceBox.style.width = boxCWidth + 'px';
            raceBox.style.textAlign = 'center';
            const raceSpan = document.createElement('span');
            raceSpan.className = 'text center-align';
            raceSpan.textContent = raceLabel;
            // Make race label smaller visually
            raceSpan.style.fontSize = '0.6em';
            // Slight nudge so its bottom lines up with other text: use translateY
            raceSpan.style.display = 'inline-block';
            raceSpan.style.transform = 'translateY(6px)'; // tweak so bottoms align visually
            raceBox.appendChild(raceSpan);

            // Right Score (Box B) - right aligned
            const rightScoreBox = document.createElement('div');
            rightScoreBox.className = 'war-box score';
            rightScoreBox.style.width = boxBWidth + 'px';
            rightScoreBox.style.textAlign = 'right';
            const rightScoreSpan = document.createElement('span');
            rightScoreSpan.className = 'text right-align';
            rightScoreSpan.textContent = score2;
            rightScoreBox.appendChild(rightScoreSpan);

            // Right Tag (Box A) - right aligned
            const rightTagBox = document.createElement('div');
            rightTagBox.className = 'war-box tag';
            rightTagBox.style.width = boxAWidth + 'px';
            rightTagBox.style.textAlign = 'right';
            const rightTagSpan = document.createElement('span');
            rightTagSpan.className = 'text right-align';
            rightTagSpan.textContent = tag2;
            rightTagBox.appendChild(rightTagSpan);

            // Append in order: leftTag, leftScore, race, rightScore, rightTag
            wrapper.appendChild(leftTagBox);
            wrapper.appendChild(leftScoreBox);
            wrapper.appendChild(raceBox);
            wrapper.appendChild(rightScoreBox);
            wrapper.appendChild(rightTagBox);

            container.appendChild(wrapper);
            // make sure container has center text alignment
            container.style.textAlign = 'center';
        }

        // Listen for config changes
        const channel = new BroadcastChannel("table_config_channel");
        channel.addEventListener("message", (event) => {
            const { name, tableid, align } = event.data;
            const urlParams = new URLSearchParams(window.location.search);

            if (urlParams.get("name") === name) {
                if (typeof tableid !== "undefined") {
                    if (tableid === "") urlParams.delete("tableid");
                    else urlParams.set("tableid", tableid);
                }
                if (typeof align !== "undefined") {
                    if (align === "" || align === null) urlParams.delete("align");
                    else urlParams.set("align", align);
                }

                const newUrl = `${window.location.pathname}?${urlParams.toString()}`;
                window.history.replaceState(null, "", newUrl);

                if (urlParams.get("tableid")) fetchAndRenderData();
                else document.getElementById("table-stats").innerHTML = "";
            }
        });

        document.addEventListener("DOMContentLoaded", fetchAndRenderData);
        setInterval(fetchAndRenderData, 5000);
    </script>
</body>
</html>
