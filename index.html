<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Table Display</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: transparent;
            font-family: 'Roboto Mono', monospace;
        }
        /* Make the element exactly 1920px wide so OBS doesn't need adjustments */
        #table-stats {
            position: absolute;
            top: 10px;
            left: 0; /* anchor to left to match a 1920px wide element */
            width: 1920px;
            font-size: 30px; /* Base font size */
            font-weight: 500;
            box-sizing: border-box;
            padding: 0 10px;
            white-space: nowrap;
        }
        /* Layout for centered two-team mode */
        .center-teams {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 90px; /* space between the two teams when centered */
        }
        .center-teams .team {
            display: inline-block;
            white-space: nowrap;
        }

        /* Default styling for text (dark grey text, black highlight) */
        .dark-mode .text-highlight {
            color: black; /* Highlighted text (e.g., player's score) */
        }
        .dark-mode .text-normal {
            color: #444444; /* Dark grey text for other elements */
        }
        /* Styling for &white parameter (light grey text, white highlight) */
        .white-mode .text-highlight {
            color: white; /* Highlighted text (e.g., player's score) */
        }
        .white-mode .text-normal {
            color: #bebebe; /* Light grey text for other elements */
        }
    </style>
</head>
<body>
    <div id="table-stats"></div>

    <script>
        // Function to format tags and avoid double brackets
        function formatTag(tag) {
            // Check if the tag already starts and ends with square brackets
            if (tag.startsWith('[') && tag.endsWith(']')) {
                return tag; // Return as-is if already formatted
            }
            return `[${tag}]`; // Otherwise, wrap it in square brackets
        }

        async function fetchAndRenderData() {
            try {
                const urlParams = new URLSearchParams(window.location.search);
                const tableId = urlParams.get("tableid");
                const playerName = urlParams.get("name");
                const align = (urlParams.get("align") || "left").toLowerCase();

                // Apply styling mode based on the presence of the &white parameter
                if (urlParams.has("white")) {
                    document.body.classList.add("white-mode");
                    document.body.classList.remove("dark-mode");
                } else {
                    document.body.classList.add("dark-mode");
                    document.body.classList.remove("white-mode");
                }

                // If 'tableid' is missing, clear the display and stop execution
                if (!tableId) {
                    document.getElementById("table-stats").innerHTML = ""; // Clear display
                    return;
                }

                // Fetch the table data using the 'tableid'
                const tableResponse = await fetch(`https://mkw-table-bot-api.jprq.live/api/html/full_scores/${tableId}`);
                if (!tableResponse.ok) {
                    // If response is invalid, clear the display
                    document.getElementById("table-stats").innerHTML = "";
                    return;
                }

                const tableHTML = await tableResponse.text();

                // Parse and format the table data (pass align option)
                const formattedData = parseAndFormatTableData(tableHTML, playerName, align);

                // Render the formatted data and apply alignment-specific layout
                renderFormattedData(formattedData, align);
            } catch (error) {
                console.error("Error fetching or rendering data:", error);
                // Clear the display in case of an error
                document.getElementById("table-stats").innerHTML = "";
            }
        }

        function parseAndFormatTableData(rawHTML, playerName, align) {
            const tempElement = document.createElement("div");
            tempElement.innerHTML = rawHTML;

            const raceInfo = tempElement.querySelector(".races_played")?.textContent || "";
            const raceMatch = raceInfo.match(/(\d+)\s*races?/i);
            const raceNumber = raceMatch ? raceMatch[1] : "1";

            const format = tempElement.querySelector(".format")?.textContent.trim() || "Unknown";

            if (format === "FFA") {
                // Handle FFA format (no teams, individual players' scores)
                const players = Array.from(tempElement.querySelectorAll(".player_wrapper")).map(player => {
                    const playerName = player.querySelector(".player_name")?.textContent.trim() || "Unknown";
                    const playerTotal = parseInt(player.querySelector(".player_total")?.textContent.trim() || "0", 10);
                    return { name: playerName, total: playerTotal };
                });

                // Sort players by their total score (descending order)
                players.sort((a, b) => b.total - a.total);

                // Format the output
                const playerScores = players.map(player => {
                    const isMatch = playerName && player.name.toLowerCase() === playerName.toLowerCase();
                    const formattedScore = isMatch
                        ? `<span class="text-highlight">${player.total}</span>`
                        : `<span class="text-normal">${player.total}</span>`;
                    return formattedScore;
                });

                return `<span class="text-normal">R${raceNumber} ${format}</span> <span class="text-normal">|</span> ${playerScores.join('<span class="text-normal">, </span>')}`;
            } else {
                // Handle other formats (teams)
                const teams = Array.from(tempElement.querySelectorAll(".team_wrapper"));
                const teamInfos = teams.map((team) => {
                    const teamName = team.querySelector(".team_name")?.textContent.trim() || "Unknown";
                    const teamScore = team.querySelector(".team_score")?.textContent.trim() || "0";
                    const players = Array.from(team.querySelectorAll(".player_name")).map(player =>
                        player.textContent.trim()
                    );

                    // Check if any player's name matches the 'name' parameter
                    const isMatch = playerName && players.some(player => player.toLowerCase() === playerName.toLowerCase());
                    const formattedTeam = isMatch
                        ? `<span class="text-highlight">${formatTag(teamName)} ${teamScore}</span>` // Highlight matching team
                        : `<span class="text-normal">${formatTag(teamName)} ${teamScore}</span>`; // Normal styling for others
                    return { name: teamName, html: formattedTeam };
                });

                // If center alignment is requested and there are exactly 2 teams, return a flex layout structure
                if (align === "center" && teamInfos.length === 2) {
                    const left = `<span class="team">${teamInfos[0].html}</span>`;
                    const right = `<span class="team">${teamInfos[1].html}</span>`;
                    // Race/format label will be shown first, then the centered two-team layout
                    return `<span class="text-normal">R${raceNumber} ${format}</span> <div class="center-teams" role="presentation">${left}${right}</div>`;
                }

                // Default: join teams with separators (left or right alignment will be applied via CSS text-align)
                const teamScores = teamInfos.map(ti => ti.html);
                return `<span class="text-normal">R${raceNumber} ${format}</span> <span class="text-normal">|</span> ${teamScores.join('<span class="text-normal"> | </span>')}`;
            }
        }

        function renderFormattedData(formattedData, align) {
            const tableContainer = document.getElementById("table-stats");
            tableContainer.innerHTML = formattedData || "";

            // Apply text alignment for non-centered two-team layouts
            // If center-mode and the HTML contains .center-teams, the flex layout handles centering already.
            if (align === "left") {
                tableContainer.style.textAlign = "left";
            } else if (align === "right") {
                tableContainer.style.textAlign = "right";
            } else if (align === "center") {
                // If center was requested, we default to center text alignment.
                // When there are 2 teams the .center-teams flex container will center them visually.
                tableContainer.style.textAlign = "center";
            } else {
                tableContainer.style.textAlign = "left";
            }
        }

        // Listen for updates from the config page via BroadcastChannel
        const channel = new BroadcastChannel("table_config_channel");
        channel.addEventListener("message", (event) => {
            const { name, tableid, align } = event.data;
            const urlParams = new URLSearchParams(window.location.search);

            // Update the URL only if the 'name' matches
            if (urlParams.get("name") === name) {
                if (typeof tableid !== "undefined") {
                    if (tableid === "") {
                        // Remove the tableid parameter from the URL
                        urlParams.delete("tableid");
                    } else {
                        // Update the tableid parameter in the URL
                        urlParams.set("tableid", tableid);
                    }
                }

                // If align provided, update it (keep if omitted)
                if (typeof align !== "undefined") {
                    if (align === "" || align === null) {
                        urlParams.delete("align");
                    } else {
                        urlParams.set("align", align);
                    }
                }

                const newUrl = `${window.location.pathname}?${urlParams.toString()}`;
                window.history.replaceState(null, "", newUrl);

                // Fetch and render new data if tableid is not empty
                if (urlParams.get("tableid")) {
                    fetchAndRenderData();
                } else {
                    // Clear the displayed data if tableid is removed
                    document.getElementById("table-stats").innerHTML = "";
                }
            }
        });

        // Fetch data immediately on page load
        document.addEventListener("DOMContentLoaded", fetchAndRenderData);

        // Automatically fetch and update the data every 5 seconds
        setInterval(fetchAndRenderData, 5000);
    </script>
</body>
</html>
