<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Table Display</title>
    <style>
        /* Prevent any scrollbars from appearing in the overlay */
        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden; /* ensure no scrollbars */
            background-color: transparent;
            font-family: 'Roboto Mono', monospace;
        }

        /* Make the element exactly 1920px wide so OBS doesn't need adjustments */
        #table-stats {
            position: absolute;
            top: 10px;
            left: 0; /* anchor to left to match a 1920px wide element */
            width: 1920px;
            font-size: 30px; /* Base font size */
            font-weight: 500;
            box-sizing: border-box;
            padding: 0 10px;
            /* allow normal wrapping/layout for war-center */
            white-space: normal;
            overflow: visible; /* allow composed elements to overflow visually without creating scrollbars */
        }

        /* Default styling for text (dark grey text, black highlight) */
        .dark-mode .text-highlight {
            color: black; /* Highlighted text (e.g., player's score) */
        }
        .dark-mode .text-normal {
            color: #444444; /* Dark grey text for other elements */
        }
        /* Styling for &white parameter (light grey text, white highlight) */
        .white-mode .text-highlight {
            color: white; /* Highlighted text (e.g., player's score) */
        }
        .white-mode .text-normal {
            color: #bebebe; /* Light grey text for other elements */
        }

        /* Flex container used for centered war layout */
        .war-center {
            display: flex;
            justify-content: center;
            align-items: flex-end; /* align bottoms so race-count can be aligned to bottom */
            gap: 12px;

            /* Outer border surrounding all cells (no inner borders) */
            border: 2px solid #333333; /* dark grey outer border */
            border-radius: 6px;
            padding: 4px; /* small padding so cell backgrounds don't touch the outer border directly */
            background: transparent;
            box-sizing: border-box;
            align-items: center;
        }

        /* Box styles */
        .war-box {
            display: flex;
            align-items: center;
            justify-content: center;
            box-sizing: border-box;
            padding: 6px 8px;
            min-height: 1em;
            /* ensure inner boxes DO NOT show borders (outer border only) */
            border: none;
        }

        /* Background colors for each cell type (centered/war layout) */
        .war-center .war-box.tag {
            background: #ff2d95; /* hot pink for tag cells */
        }
        .war-center .war-box.score {
            background: #6f6f6f; /* less dark grey for score cells */
        }
        .war-center .war-box.race {
            background: #dcdcdc; /* light grey for race count cell */
        }

        /* Ensure text colors contrast with the backgrounds in war-center */
        .war-center .war-box.tag .text {
            color: #ffffff;
            font-weight: 700;
        }
        .war-center .war-box.score .text {
            color: #ffffff;
            font-weight: 700;
        }
        .war-center .war-box.race .text {
            color: #000000;
            font-weight: 700;
        }

        .war-box .text {
            display: block;
            font-family: 'Roboto Mono', monospace;
            font-weight: 600;
            line-height: 1;
            white-space: nowrap;
        }

        .war-box.tag .text { /* Box A styling */
            font-weight: 700;
        }

        .war-box.score .text { /* Box B styling */
            font-weight: 700;
        }

        .war-box.race .text { /* Box C styling: slightly smaller */
            font-weight: 700;
            line-height: 1;
        }

        /* Text alignment helpers inside each box */
        .left-align { text-align: left; width: 100%; padding-left: 6px; box-sizing: border-box; }
        .right-align { text-align: right; width: 100%; padding-right: 6px; box-sizing: border-box; }
        .center-align { text-align: center; width: 100%; box-sizing: border-box; }
    </style>
</head>
<body>
    <div id="table-stats"></div>

    <script>
        // Utility: format tags consistently
        function formatTag(tag) {
            if (!tag) return "[Unknown]";
            if (tag.startsWith('[') && tag.endsWith(']')) return tag;
            return `[${tag}]`;
        }

        async function fetchAndRenderData() {
            try {
                const urlParams = new URLSearchParams(window.location.search);
                const tableId = urlParams.get("tableid");
                const playerName = urlParams.get("name");
                const align = (urlParams.get("align") || "left").toLowerCase();

                // styling mode
                if (urlParams.has("white")) {
                    document.body.classList.add("white-mode");
                    document.body.classList.remove("dark-mode");
                } else {
                    document.body.classList.add("dark-mode");
                    document.body.classList.remove("white-mode");
                }

                if (!tableId) {
                    document.getElementById("table-stats").innerHTML = "";
                    return;
                }

                const tableResponse = await fetch(`https://mkw-table-bot-api.jprq.live/api/html/full_scores/${tableId}`);
                if (!tableResponse.ok) {
                    document.getElementById("table-stats").innerHTML = "";
                    return;
                }

                const tableHTML = await tableResponse.text();
                const parsed = parseTableData(tableHTML);

                // compute effectiveAlign: allow center only when teams length === 2
                let effectiveAlign;
                if (align === 'center') {
                    if (parsed && parsed.type === 'teams' && Array.isArray(parsed.teams) && parsed.teams.length === 2) {
                        effectiveAlign = 'center';
                    } else {
                        effectiveAlign = 'left';
                    }
                } else if (align === 'right') {
                    effectiveAlign = 'right';
                } else {
                    effectiveAlign = 'left';
                }

                render(parsed, effectiveAlign, playerName);
            } catch (error) {
                console.error("Error fetching or rendering data:", error);
                document.getElementById("table-stats").innerHTML = "";
            }
        }

        // Parse table HTML into a structured object
        function parseTableData(rawHTML) {
            const temp = document.createElement("div");
            temp.innerHTML = rawHTML;

            const raceInfo = temp.querySelector(".races_played")?.textContent || "";
            const raceMatch = raceInfo.match(/(\d+)\s*races?/i);
            const raceNumber = raceMatch ? raceMatch[1] : "1";

            const format = temp.querySelector(".format")?.textContent.trim() || "Unknown";

            if (format === "FFA") {
                const players = Array.from(temp.querySelectorAll(".player_wrapper")).map(player => {
                    const pName = player.querySelector(".player_name")?.textContent.trim() || "Unknown";
                    const pTotal = parseInt(player.querySelector(".player_total")?.textContent.trim() || "0", 10);
                    return { name: pName, total: pTotal };
                });
                players.sort((a,b) => b.total - a.total);
                return { type: 'ffa', raceNumber, format, players };
            } else {
                const teams = Array.from(temp.querySelectorAll(".team_wrapper")).map(team => {
                    const teamName = team.querySelector(".team_name")?.textContent.trim() || "Unknown";
                    const teamScore = team.querySelector(".team_score")?.textContent.trim() || "0";
                    const players = Array.from(team.querySelectorAll(".player_name")).map(p => p.textContent.trim());
                    return { name: teamName, score: teamScore, players };
                });

                return { type: 'teams', raceNumber, format, teams };
            }
        }

        // Render structured data according to effectiveAlign ('left'|'right'|'center')
        function render(parsed, effectiveAlign, playerName) {
            const container = document.getElementById("table-stats");
            container.innerHTML = "";

            if (!parsed) return;

            // Helper to check player membership (case-insensitive)
            function playerInTeam(team, player) {
                if (!player) return false;
                return Array.isArray(team.players) && team.players.some(p => p.toLowerCase() === player.toLowerCase());
            }

            if (parsed.type === 'ffa') {
                // FFA rendering: highlight the set player if present (use text-highlight)
                const playerScores = parsed.players.map(player => {
                    const isMatch = playerName && player.name.toLowerCase() === playerName.toLowerCase();
                    const cls = isMatch ? 'text-highlight' : 'text-normal';
                    return `<span class="${cls}">${player.total}</span>`;
                });
                container.innerHTML = `<span class="text-normal">R${parsed.raceNumber}</span> <span class="text-normal">|</span> ${playerScores.join('<span class="text-normal">, </span>')}`;
                container.style.textAlign = effectiveAlign === 'right' ? 'right' : (effectiveAlign === 'center' ? 'center' : 'left');
                return;
            }

            // Teams rendering
            if (effectiveAlign === 'center' && parsed.type === 'teams' && parsed.teams.length === 2) {
                // centered war layout intentionally has no highlighting (per your request)
                renderWarCenter(container, parsed, playerName);
                return;
            }

            // Default teams rendering (left/right/center simple join) - apply highlighting for the team containing player
            const teamParts = parsed.teams.map(team => {
                const isMatch = playerName && playerInTeam(team, playerName);
                const cls = isMatch ? 'text-highlight' : 'text-normal';
                return `<span class="${cls}">${formatTag(team.name)} ${team.score}</span>`;
            });

            container.innerHTML = `<span class="text-normal">R${parsed.raceNumber}</span> <span class="text-normal">|</span> ${teamParts.join('<span class="text-normal"> | </span>')}`;

            container.style.textAlign = effectiveAlign === 'right' ? 'right' : (effectiveAlign === 'center' ? 'center' : 'left');
        }

        // Build the special "Centered (War)" layout in DOM (not plain HTML string)
        function renderWarCenter(container, parsed, playerName) {
            // Safety checks
            if (!parsed || parsed.type !== 'teams' || parsed.teams.length !== 2) return;

            // helper to test if a team contains the player (case-insensitive)
            function teamHasPlayer(team, playerName) {
                if (!playerName) return false;
                const lower = playerName.toLowerCase();
                return Array.isArray(team.players) && team.players.some(p => p.toLowerCase() === lower);
            }

            const teamA = parsed.teams[0];
            const teamB = parsed.teams[1];

            // Decide left/right team:
            // - If exactly one team contains the set player -> that team on the left.
            // - Otherwise -> left = first team alphabetically (by team.name, case-insensitive).
            let leftTeam, rightTeam;
            const aHas = teamHasPlayer(teamA, playerName);
            const bHas = teamHasPlayer(teamB, playerName);

            if (aHas && !bHas) {
                leftTeam = teamA; rightTeam = teamB;
            } else if (bHas && !aHas) {
                leftTeam = teamB; rightTeam = teamA;
            } else {
                // alphabetical by name (case-insensitive)
                const aName = (teamA.name || "").toLowerCase();
                const bName = (teamB.name || "").toLowerCase();
                if (aName.localeCompare(bName) <= 0) { leftTeam = teamA; rightTeam = teamB; }
                else { leftTeam = teamB; rightTeam = teamA; }
            }

            // Measure monospace character width at the container font-size.
            const meas = document.createElement('span');
            meas.style.position = 'absolute';
            meas.style.left = '-9999px';
            meas.style.top = '-9999px';
            meas.style.visibility = 'hidden';
            meas.style.fontFamily = getComputedStyle(container).fontFamily || 'Roboto Mono, monospace';
            meas.style.fontSize = getComputedStyle(container).fontSize || '30px';
            meas.style.fontWeight = getComputedStyle(container).fontWeight || '500';
            meas.textContent = '0'.repeat(80);
            document.body.appendChild(meas);
            const totalWidth = meas.getBoundingClientRect().width || 1;
            const charWidth = totalWidth / 80;
            document.body.removeChild(meas);

            const padding = Math.max(4, Math.round(charWidth * 0.6));

            // IMPORTANT: For centered layout we DO NOT add brackets around tags.
            const tagLeft = (leftTeam.name || "Unknown");
            const tagRight = (rightTeam.name || "Unknown");
            const scoreLeft = leftTeam.score;
            const scoreRight = rightTeam.score;
            // Race label now contains only the race count (format removed)
            const raceLabel = `R${parsed.raceNumber}`;

            // Compute widths in px
            const lenTagLeft = tagLeft.length;
            const lenTagRight = tagRight.length;
            const boxAChars = Math.max(lenTagLeft, lenTagRight); // Box A: width based on larger tag
            const boxAWidth = Math.ceil(boxAChars * charWidth) + padding * 2;

            const boxBChars = 3; // 3 character widths
            const boxBWidth = Math.ceil(boxBChars * charWidth) + padding * 2;

            const boxCChars = Math.max(1, Math.floor(boxBChars * 0.8)); // slightly smaller than B
            const boxCWidth = Math.ceil(boxCChars * charWidth) + padding * 2;

            // Build DOM nodes
            const wrapper = document.createElement('div');
            wrapper.className = 'war-center';
            wrapper.style.gap = Math.round(charWidth * 1.2) + 'px';

            // Left Tag (Box A) - left aligned text inside
            const leftTagBox = document.createElement('div');
            leftTagBox.className = 'war-box tag';
            leftTagBox.style.width = boxAWidth + 'px';
            leftTagBox.style.textAlign = 'left';
            const leftTagSpan = document.createElement('span');
            leftTagSpan.className = 'text left-align';
            leftTagSpan.textContent = tagLeft;
            leftTagBox.appendChild(leftTagSpan);

            // Left Score (Box B) - left aligned
            const leftScoreBox = document.createElement('div');
            leftScoreBox.className = 'war-box score';
            leftScoreBox.style.width = boxBWidth + 'px';
            leftScoreBox.style.textAlign = 'left';
            const leftScoreSpan = document.createElement('span');
            leftScoreSpan.className = 'text left-align';
            leftScoreSpan.textContent = scoreLeft;
            leftScoreBox.appendChild(leftScoreSpan);

            // Race Count (Box C) - center aligned, slightly smaller
            const raceBox = document.createElement('div');
            raceBox.className = 'war-box race';
            raceBox.style.width = boxCWidth + 'px';
            raceBox.style.textAlign = 'center';
            const raceSpan = document.createElement('span');
            raceSpan.className = 'text center-align';
            raceSpan.textContent = raceLabel;
            raceSpan.style.fontSize = '0.6em';
            raceSpan.style.display = 'inline-block';
            raceSpan.style.transform = 'translateY(4px)'; // keep the slight vertical adjustment
            raceBox.appendChild(raceSpan);

            // Right Score (Box B) - right aligned
            const rightScoreBox = document.createElement('div');
            rightScoreBox.className = 'war-box score';
            rightScoreBox.style.width = boxBWidth + 'px';
            rightScoreBox.style.textAlign = 'right';
            const rightScoreSpan = document.createElement('span');
            rightScoreSpan.className = 'text right-align';
            rightScoreSpan.textContent = scoreRight;
            rightScoreBox.appendChild(rightScoreSpan);

            // Right Tag (Box A) - right aligned
            const rightTagBox = document.createElement('div');
            rightTagBox.className = 'war-box tag';
            rightTagBox.style.width = boxAWidth + 'px';
            rightTagBox.style.textAlign = 'right';
            const rightTagSpan = document.createElement('span');
            rightTagSpan.className = 'text right-align';
            rightTagSpan.textContent = tagRight;
            rightTagBox.appendChild(rightTagSpan);

            // Append in order: leftTag, leftScore, race, rightScore, rightTag
            wrapper.appendChild(leftTagBox);
            wrapper.appendChild(leftScoreBox);
            wrapper.appendChild(raceBox);
            wrapper.appendChild(rightScoreBox);
            wrapper.appendChild(rightTagBox);

            // clear container and append
            container.innerHTML = '';
            container.appendChild(wrapper);

            // center the overall container
            container.style.textAlign = 'center';
        }

        // Listen for config changes
        const channel = new BroadcastChannel("table_config_channel");
        channel.addEventListener("message", (event) => {
            const { name, tableid, align } = event.data;
            const urlParams = new URLSearchParams(window.location.search);

            if (urlParams.get("name") === name) {
                if (typeof tableid !== "undefined") {
                    if (tableid === "") urlParams.delete("tableid");
                    else urlParams.set("tableid", tableid);
                }
                if (typeof align !== "undefined") {
                    if (align === "" || align === null) urlParams.delete("align");
                    else urlParams.set("align", align);
                }

                const newUrl = `${window.location.pathname}?${urlParams.toString()}`;
                window.history.replaceState(null, "", newUrl);

                if (urlParams.get("tableid")) fetchAndRenderData();
                else document.getElementById("table-stats").innerHTML = "";
            }
        });

        document.addEventListener("DOMContentLoaded", fetchAndRenderData);
        setInterval(fetchAndRenderData, 5000);
    </script>
</body>
</html>
