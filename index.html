<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Table Display</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: transparent;
            font-family: 'Roboto Mono', monospace;
        }
        #table-stats {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 30px; /* Base font size */
            font-weight: 500;
            text-align: center; /* Center align text */
        }
        /* Default styling for text (dark grey text, black highlight) */
        .dark-mode .text-highlight {
            color: black; /* Highlighted text (e.g., player's score) */
        }
        .dark-mode .text-normal {
            color: #444444; /* Dark grey text for other elements */
        }
        /* Styling for &white parameter (light grey text, white highlight) */
        .white-mode .text-highlight {
            color: white; /* Highlighted text (e.g., player's score) */
        }
        .white-mode .text-normal {
            color: #bebebe; /* Light grey text for other elements */
        }
    </style>
</head>
<body>
    <div id="table-stats"></div>

    <script>
        // Function to format tags and avoid double brackets
        function formatTag(tag) {
            if (tag.startsWith('[') && tag.endsWith(']')) {
                return tag;
            }
            return `[${tag}]`;
        }

        async function fetchAndRenderData() {
            try {
                const urlParams = new URLSearchParams(window.location.search);
                const tableId = urlParams.get("tableid");
                const playerName = urlParams.get("name");
                const isWarMode = urlParams.has("war");

                // Apply styling mode based on the presence of the &white parameter
                if (urlParams.has("white")) {
                    document.body.classList.add("white-mode");
                    document.body.classList.remove("dark-mode");
                } else {
                    document.body.classList.add("dark-mode");
                    document.body.classList.remove("white-mode");
                }

                if (!tableId) {
                    document.getElementById("table-stats").innerHTML = "";
                    return;
                }

                const tableResponse = await fetch(`https://mkw-table-bot-api.jprq.site/api/html/full_scores/${tableId}`);
                if (!tableResponse.ok) {
                    document.getElementById("table-stats").innerHTML = "";
                    return;
                }

                const tableHTML = await tableResponse.text();
                const formattedData = parseAndFormatTableData(tableHTML, playerName, isWarMode);
                renderFormattedData(formattedData, isWarMode);
            } catch (error) {
                console.error("Error fetching or rendering data:", error);
                document.getElementById("table-stats").innerHTML = "";
            }
        }

        function parseAndFormatTableData(rawHTML, playerName, isWarMode) {
            const tempElement = document.createElement("div");
            tempElement.innerHTML = rawHTML;

            const raceInfo = tempElement.querySelector(".races_played")?.textContent || "";
            const raceMatch = raceInfo.match(/(\d+)\s*races?/i);
            const raceNumber = raceMatch ? raceMatch[1] : "1";

            const format = tempElement.querySelector(".format")?.textContent.trim() || "Unknown";

            if (!isWarMode || format === "FFA") {
                return parseFFAFormat(tempElement, playerName, raceNumber, format);
            } else {
                const teams = Array.from(tempElement.querySelectorAll(".team_wrapper"));
                if (teams.length !== 2) {
                    return parseFFAFormat(tempElement, playerName, raceNumber, format);
                }

                const teamData = teams.map(team => {
                    const teamName = team.querySelector(".team_name")?.textContent.trim() || "Unknown";
                    const teamScore = team.querySelector(".team_score")?.textContent.trim() || "0";
                    const players = Array.from(team.querySelectorAll(".player_name")).map(player =>
                        player.textContent.trim()
                    );
                    return { name: teamName, score: teamScore, players };
                });

                let [team1, team2] = teamData;
                if (playerName) {
                    const playerTeam = teamData.find(team =>
                        team.players.some(player => player.toLowerCase() === playerName.toLowerCase())
                    );
                    if (playerTeam) {
                        team1 = playerTeam;
                        team2 = teamData.find(team => team !== playerTeam);
                    }
                } else {
                    [team1, team2] = teamData.sort((a, b) => a.name.localeCompare(b.name));
                }

                return `${formatTag(team1.name)} ${team1.score} R${raceNumber} ${team2.score} ${formatTag(team2.name)}`;
            }
        }

        function renderFormattedData(formattedData, isWarMode) {
            const tableContainer = document.getElementById("table-stats");
            tableContainer.innerHTML = formattedData;

            if (isWarMode) {
                tableContainer.style.textAlign = "center";
            } else {
                tableContainer.style.textAlign = "left";
            }
        }

        function parseFFAFormat(tempElement, playerName, raceNumber, format) {
            const players = Array.from(tempElement.querySelectorAll(".player_wrapper")).map(player => {
                const playerName = player.querySelector(".player_name")?.textContent.trim() || "Unknown";
                const playerTotal = parseInt(player.querySelector(".player_total")?.textContent.trim() || "0", 10);
                return { name: playerName, total: playerTotal };
            });

            players.sort((a, b) => b.total - a.total);

            const playerScores = players.map(player => {
                const isMatch = playerName && player.name.toLowerCase() === playerName.toLowerCase();
                return isMatch
                    ? `<span class="text-highlight">${player.total}</span>`
                    : `<span class="text-normal">${player.total}</span>`;
            });

            return `<span class="text-normal">R${raceNumber} ${format}</span> <span class="text-normal">|</span> ${playerScores.join('<span class="text-normal">, </span>')}`;
        }

        document.addEventListener("DOMContentLoaded", fetchAndRenderData);
        setInterval(fetchAndRenderData, 5000);
    </script>
</body>
</html>
